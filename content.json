{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-09-09T05:02:03.218Z","updated":"2023-09-09T05:02:03.219Z","comments":true,"path":"2023/09/09/hello-world/","link":"","permalink":"http://example.com/2023/09/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"C++ 继承与派生","slug":"C-继承与派生","date":"2023-09-06T14:12:29.000Z","updated":"2023-09-06T15:00:53.708Z","comments":true,"path":"2023/09/06/C-继承与派生/","link":"","permalink":"http://example.com/2023/09/06/C-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","excerpt":"","text":"C++继承与派生1.1 C++继承和派生简明教程C++中的继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承类似，例如儿子继承父亲的财富 继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。 在C++中，派生和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。 被继承的类成为父类或者基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。 派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能。 以下是两种典型的使用继承和场景。 当你创建的新类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承，这样不但会减少代码量，而且新类会拥有基类的所有功能。 当你需要创建多个类，他们拥有很多相似的成员变量后成员函数时，也可以使用继承。可以将这些类的共同成员提取出来，定义为基类，然后从基类继承，既可以节省代码，也方便后续修改。 继承的一般语法是： 1234class 派生类名:[继承方式]基类名&#123; 派生类新增加的成员&#125; 继承方式包含public、private、和protected，此项是可选的，如果不写，那么默认为private。下面就将介绍这些不同的继承方式。 1.2 C++三钟继承方式public、protected、private修饰类的成员 类成员的访问权限由高到低依次为public–&gt;protected–&gt;private。 public成员可以通过对象来访问。private成员不能通过对象来访问。protected成员也不能通过对象来访问。但是当存在继承关系是，protected和private就不一样了：基类中的protected成员可以在派生类中使用，而基类的private成员不能在派生类中使用。 不同的继承方式会影响基类成员在派生类中的访问权限。 public继承方式 基类中所有public成员在派生类中为public属性。 基类中所有protected成员在派生类中为protected属性； 基类中所有private成员在派生类中不能使用； protected继承方式 基类中的所有public成员在派生类中为protected属性。 基类中的所有protected成员在派生类中为protected属性。 基类中的所有private成员在派生类中不可以使用。 private继承方式 基类中的所有public成员在派生类中均为private属性。 基类中的所有protected成员在派生类中均为private属性。 基类中的所有private成员在派生类中不可以使用。 通过上面的分析可以发现。 基类成员在派生类中的访问权限不得高于继承方式中指定的权限，也就是说，继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。 不管继承方式如何，基类中的private成员在派生类中始终是不可被访问的（不能在派生类中被调用或访问） 如果希望基类的成员能够被派生类继承并且毫无障碍的使用，那么这些成员只能声明为public或protected，只有希望在派生类中使用的成员才被声明为private、 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为protected。 注意：我们这里说的基类的private成员不能在派生类中使用，并没有说基类的private成员不能被继承。实际上，基类的private成员是能够被继承的，并且（成员变量）会占用派生对象的内存，它只是在派生类中不可见，导致无法使用。private成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。 由于private和protected继承方式会改变基类成员在派生类中的访问权限 ，导致继承关系复杂，所以实际开发中我们一般使用public。 在派生类中访问基类private成员的唯一方法就是借助基类的非private成员函数，如果基类没有非privtea成语函数，那么该成员在派生类中将无法访问。 改变访问权限使用using关键字可以改变基类成员在派生类中的访问权限，例如将public改为private，将protected改为public。注意；using 只能改变基类中public和protetecd成员的访问权限，不能改变private成员的访问权限，因为基类中private成员在派生类中是不可见的，根本不能使用，所以基类中的private成员在派生类中无论如何都不能访问。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 对象的内存模型","slug":"C-对象的内存模型","date":"2023-09-04T14:33:40.000Z","updated":"2023-09-06T12:43:24.759Z","comments":true,"path":"2023/09/04/C-对象的内存模型/","link":"","permalink":"http://example.com/2023/09/04/C-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"1. C++ 对象的内存模型类是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。直观的认识是，如果创建了10个，就要分别为这10个对象的成员变量和成员函数分配内存，如图:(需要画个简图) 不同的对象的成员变量的值可能不同，需要单独分配内存在存储。但是不同对象的成员函数的代码是一样的，上面的内存模型保存了10份相同的代码，浪费了不少空间，可以将这些代码片段压缩成一份。 事实上编译器也是这样做的，编译器会将成员变量和成员函数分开来存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。 成员变量在堆区或者栈区分配内存，成员函数在代码区分配内存。 2. C++函数编译原理和成员函数的实现 从上节的分析中可以看出，对象的内存中只保留了成员变量，除此之外没有任何其他信息，程序运行时不知道stu的类型为Student，也不知道它还有四个成员函数setname，setage，setscore，show，C++究竟是如何通过对象调用成员函数的呢 2.1 C++函数的编译 C++和C语言的编译方式不同，C语言中的函数在编译时名字不变，或者只是简单的加一个下划线，（不同的编译器有不同的现实），例如，fun()编译后为func()或者_func()。 而C++中的函数在编译时会根据它所在的命名空间、它所属的类，以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做名字编码(Name Mangling)，是通过一种特殊的算法来实现的。 这种编译算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名，Name Mangling可以确保新函数名的唯一性，只有函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。 2.2 成员函数的调用 从上面可知，成员函数最终被编译成与对象无关的全局函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做处理，直接调用就可以。 如果成员函数中使用到了成员变量该怎么办呢？成员变量的作用域不是全局，不经过任何处理就无法在函数内部访问。 C++规定,编译成员函数时要额外添加一个参数,把当前对象的指针传递进去,通过指针来访问成员变量。 这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表面上看到的刚好相反，通过对象调用成语函数时，不是用过对象找函数，而是通过函数找对象。 这一切都是隐式完成的，对程序员来说完全透明，就好像这个额外的参数不存在一样。 最后需要提示的是， Demo*const中的const表示指针不能被修改，p只能指向当前对象，不能指向其他对象。 ————————————————————————————最美的不是下雨天，是曾与你躲过雨的屋檐","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]}